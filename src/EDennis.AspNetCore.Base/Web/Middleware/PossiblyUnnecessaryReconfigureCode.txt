using Microsoft.Extensions.Configuration;
using System;
using System.Collections.Generic;
///
/// All config model classes implement IReconfigurable
///
namespace EDennis.AspNetCore.Base {
    public class Apis : Dictionary<string,Api>, IReconfigurable {
        public string ConfigurationKey { get; set; }
        public IConfiguration Configuration { get; set; }
        public void Reconfigure() {             
            if(Configuration != null && ConfigurationKey != null )
                Configuration.GetSection(ConfigurationKey).Bind(this);
        }
    }
}


    public interface IReconfigurable {
        public string ConfigurationKey { get; set; }
        public IConfiguration Configuration { get; set; }
        public void Reconfigure() {
            if(Configuration != null && ConfigurationKey != null)
                Configuration.GetSection(ConfigurationKey).Bind(this);
        }
    }


using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.DependencyInjection;
using System.Collections.Generic;

namespace EDennis.AspNetCore.Base {
    public interface IServiceConfig {
        IConfiguration Configuration { get; }
        IServiceCollection Services { get; }

        T Bind<T>(string path) where T : class, IReconfigurable, new();
        void Configure<T>(string path) where T : class, IReconfigurable, new();
        T BindAndConfigure<T>(string path) where T : class, IReconfigurable, new();


        T GetObject<T>(string path) where T : class, IReconfigurable, new();

        T GetParentObject<T>(string path) where T : class, IReconfigurable, new();

        string GetParentPath(string path);
    }
}


using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.DependencyInjection.Extensions;
using System.Collections.Generic;

namespace EDennis.AspNetCore.Base {

    /// <summary>
    /// Provides a convenience class for navigating the configuration tree
    /// while holding onto the service collection.  With extension methods
    /// (typically on IServiceConfig), this class can faciliate building a
    /// fluent API for configuration of an application.
    /// </summary>
    public class ServiceConfig : IServiceConfig {

        public IServiceCollection Services { get; }
        public IConfiguration Configuration { get; }

        public T Bind<T>(string path) where T : class, IReconfigurable, new() {
            var configSection = Configuration.GetSection(path);
            var obj = new T { ConfigurationKey = path, Configuration = Configuration };
            configSection.Bind(obj);
            if(!_objects.ContainsKey(path))
                _objects.Add(path, obj);
            return obj;
        }

        public void Configure<T>(string path) where T : class, IReconfigurable, new() {
            var configSection = Configuration.GetSection(path);
            Services.Configure<T>(configSection);
            Services.PostConfigure<T>(opts => {
                opts.Configuration = Configuration;
                opts.ConfigurationKey = path;
            });
        }

        public T BindAndConfigure<T>(string path) where T : class, IReconfigurable, new() {
            var configSection = Configuration.GetSection(path);
            Services.Configure<T>(configSection);
            Services.PostConfigure<T>(opts => {
                opts.Configuration = Configuration;
                opts.ConfigurationKey = path;
            });
            var obj = new T { ConfigurationKey = path, Configuration = Configuration };
            configSection.Bind(obj);
            _objects.Add(path, obj);
            return obj;
        }

        //TODO: Not Needed?
        public T GetObject<T>(string path) where T: class, IReconfigurable, new() {
            if (!_objects.ContainsKey(path))
                return null;
            return (T)_objects[path];
        }

        //TODO: Not Needed?
        public T GetParentObject<T>(string path) where T: class, IReconfigurable, new() {
            var parentPath = GetParentPath(path);
            if (!_objects.ContainsKey(parentPath))
                return null;
            return (T)_objects[parentPath];
        }

        public string GetParentPath(string path) {
            string parentPath = "";
            if (path.Contains(":"))
                parentPath = path.Substring(0, path.LastIndexOf(':'));
            return parentPath;
        }


        //TODO: Not Needed?
        readonly Dictionary<string, object> _objects = new Dictionary<string, object>();

        public ServiceConfig(IServiceCollection services, IConfiguration config) {
            Configuration = config;
            Services = services;
        }

    }
}


    //in ConfigurationMiddleware ...

                    if (configuration.ContainsKey("Apis")) {
                        var obj = serviceProvider.GetRequiredService<IOptionsMonitor<Apis>>();
                        obj.CurrentValue.Reconfigure();
                    }

                    if (configuration.ContainsKey("ScopeProperties")) {
                        var obj = serviceProvider.GetRequiredService<IOptionsMonitor<ScopePropertiesSettings>>();
                        obj.CurrentValue.Reconfigure();
                    }

                    if (configuration.ContainsKey("MockClient")) {
                        var obj = serviceProvider.GetRequiredService<IOptionsMonitor<ActiveMockClientSettings>>();
                        obj.CurrentValue.Reconfigure();
                    }

                    if (configuration.ContainsKey("MockHeaders")) {
                        var obj = serviceProvider.GetRequiredService<IOptionsMonitor<MockHeaderSettingsCollection>>();
                        obj.CurrentValue.Reconfigure();
                    }

                    if (configuration.ContainsKey("HeadersToClaims")) {
                        var obj = serviceProvider.GetRequiredService<IOptionsMonitor<HeadersToClaims>>();
                        obj.CurrentValue.Reconfigure();
                    }

                    if (configuration.ContainsKey("UserLogger")) {
                        var obj = serviceProvider.GetRequiredService<IOptionsMonitor<UserLoggerSettings>>();
                        obj.CurrentValue.Reconfigure();
                    }

